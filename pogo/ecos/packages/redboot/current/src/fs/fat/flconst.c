//........................................................................................
//........................................................................................
//.. Last Modified By: Eric Gibbs	ericg@iobjects.com									..	
//.. Modification date: 8/16/2000														..
//........................................................................................
//.. Copyright:(c) 1995-2000 Interactive Objects Inc.  									..
//..	 All rights reserved. This code may not be redistributed in source or linkable  ..
//.. 	 object form without the express written consent of Interactive Objects.        ..
//.. Contact Information: www.iobjects.com												..
//........................................................................................
//........................................................................................
/******************************************************************************
* Filename: flconst.c - Constant declarations
*
* SanDisk Host Developer's Toolkit
*
* Copyright (c) 1996-1999 SanDisk Corporation
* Copyright EBS Inc. 1996
* All rights reserved.
* This code may not be redistributed in source or linkable object form
* without the consent of its author.
*
* Description:
*       Sandisk master partition record and boot block.
*
*****************************************************************************/

#include <fs/fat/sdconfig.h>

#if (USE_FILE_SYSTEM)
#include <fs/fat/pcdisk.h>


/* String constants */
const UTEXT string_star[4] = {0x2A, 0x00, 0x00, 0x00};      /* "*" */
const UTEXT string_3_spaces[4] = {0x20, 0x20, 0x20, 0x00}; /* "   " */
const UTEXT string_backslash[4] = {0x5C,0x00,0x00, 0x00}; /* "\\" */
const UTEXT string_fat_12[10] = {0x46,0x41,0x54,0x31,0x32,0x20,0x20,0x20,0x00,0x00};/* "FAT12" */
const UTEXT string_fat_16[10] = {0x46,0x41,0x54,0x31,0x36,0x20,0x20,0x20,0x00,0x00};/* "FAT16" */
const UTEXT string_fat_32[10] = {0x46,0x41,0x54,0x33,0x32,0x20,0x20,0x20,0x00,0x00};/* "FAT32" */
const UTEXT string_padded_dot[10] = {0x2E,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00, 0x00}; /* ".       "*/
const UTEXT string_padded_dot_dot[10] = {0x2E,0x2E,0x20,0x20,0x20,0x20,0x20,0x20,0x00, 0x00}; /* "..      "*/


/* 
Changing to '/' and "//" should give unix style path separators. 
This is not tested but it should work ,
*/
const UTEXT string_null[1] = {0x00};
const UTEXT char_backslash = 0x5C;      /* '\\' */
const UTEXT char_forwardslash = 0x2F;     /* '/'  */



#if (RTFS_WRITE)

#if (LITTLE_ENDIAN)
/* Sandisk partition block. Master boot record. */
const UINT16 part_boot[218/2] = {
0x33FA, 0x8EC0, 0xBCD0, 0x7C00, 0xF48B, 0x0750, 0x1F50, 0xFCFB,
0x00BF, 0xB906, 0x0100, 0xA5F2, 0x1DEA, 0x0006, 0xBE00, 0x07BE,
0x04B3, 0x3C80, 0x7480, 0x800E, 0x003C, 0x1C75, 0xC683, 0xFE10,
0x75CB, 0xCDEF, 0x8B18, 0x8B14, 0x024C, 0xEE8B, 0xC683, 0xFE10,
0x74CB, 0x801A, 0x003C, 0xF474, 0x8BBE, 0xAC06, 0x003C, 0x0B74,
0xBB56, 0x0007, 0x0EB4, 0x10CD, 0xEB5E, 0xEBF0, 0xBFFE, 0x0005,
0x00BB, 0xB87C, 0x0201, 0xCD57, 0x5F13, 0x0C73, 0xC033, 0x13CD,
0x754F, 0xBEED, 0x06A3, 0xD3EB, 0xC2BE, 0xBF06, 0x7DFE, 0x3D81,
0xAA55, 0xC775, 0xF58B, 0x00EA, 0x007C, 0x4900, 0x766E, 0x6C61,
0x6469, 0x7020, 0x7261, 0x6974, 0x6974, 0x6E6F, 0x7420, 0x6261,
0x656C, 0x4500, 0x7272, 0x726F, 0x6C20, 0x616F, 0x6964, 0x676E,
0x6F20, 0x6570, 0x6172, 0x6974, 0x676E, 0x7320, 0x7379, 0x6574,
0x006D, 0x694D, 0x7373, 0x6E69, 0x2067, 0x706F, 0x7265, 0x7461,
0x6E69, 0x2067, 0x7973, 0x7473, 0x6D65};

/* Boot code in the sandisk boot block */
const UINT16 bootcode[202/2] = {
0x3CEB, 0x4D90, 0x4453, 0x534F, 0x2E35, 0x0030, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0xB8FA, 0x0000, 0xD08E, 0x00BC, 0x8E7C,
0x8EC0, 0xFBD8, 0xBEFC, 0x006A, 0xC681, 0x7C00, 0x0AAC, 0x74C0,
0xB40A, 0xB70E, 0xB300, 0xCD07, 0xEB10, 0x33F1, 0xCDC0, 0xCD16,
0xBE19, 0x00B3, 0xC681, 0x7C00, 0xE2EB, 0x0A0D, 0x6F4E, 0x2D6E,
0x7953, 0x7473, 0x6D65, 0x6420, 0x7369, 0x206B, 0x726F, 0x6420,
0x7369, 0x206B, 0x7265, 0x6F72, 0x0D72, 0x520A, 0x7065, 0x616C,
0x6563, 0x6120, 0x646E, 0x7320, 0x7274, 0x6B69, 0x2065, 0x6E61,
0x2079, 0x656B, 0x2079, 0x6877, 0x6E65, 0x7220, 0x6165, 0x7964,
0x0A0D, 0x0D00, 0x440A, 0x7369, 0x206B, 0x6F42, 0x746F, 0x6620,
0x6961, 0x756C, 0x6572, 0x0A0D, 0x0000};

#else
/* Boot code in the sandisk partition block. Master boot record. */
const UINT16 part_boot[218/2] = {
0xFA33, 0xC08E, 0xD0BC, 0x007C, 0x8BF4, 0x5007, 0x501F, 0xFBFC,
0xBF00, 0x06B9, 0x0001, 0xF2A5, 0xEA1D, 0x0600, 0x00BE, 0xBE07,
0xB304, 0x803C, 0x8074, 0x0E80, 0x3C00, 0x751C, 0x83C6, 0x10FE,
0xCB75, 0xEFCD, 0x188B, 0x148B, 0x4C02, 0x8BEE, 0x83C6, 0x10FE,
0xCB74, 0x1A80, 0x3C00, 0x74F4, 0xBE8B, 0x06AC, 0x3C00, 0x740B,
0x56BB, 0x0700, 0xB40E, 0xCD10, 0x5EEB, 0xF0EB, 0xFEBF, 0x0500,
0xBB00, 0x7CB8, 0x0102, 0x57CD, 0x135F, 0x730C, 0x33C0, 0xCD13,
0x4F75, 0xEDBE, 0xA306, 0xEBD3, 0xBEC2, 0x06BF, 0xFE7D, 0x813D,
0x55AA, 0x75C7, 0x8BF5, 0xEA00, 0x7C00, 0x0049, 0x6E76, 0x616C,
0x6964, 0x2070, 0x6172, 0x7469, 0x7469, 0x6F6E, 0x2074, 0x6162,
0x6C65, 0x0045, 0x7272, 0x6F72, 0x206C, 0x6F61, 0x6469, 0x6E67,
0x206F, 0x7065, 0x7261, 0x7469, 0x6E67, 0x2073, 0x7973, 0x7465,
0x6D00, 0x4D69, 0x7373, 0x696E, 0x6720, 0x6F70, 0x6572, 0x6174,
0x696E, 0x6720, 0x7379, 0x7374, 0x656D};

/* Boot code in the sandisk boot block */
const UINT16 bootcode[202/2] = {
0xEB3C, 0x904D, 0x5344, 0x4F53, 0x352E, 0x3000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0xFAB8, 0x0000, 0x8ED0, 0xBC00, 0x7C8E,
0xC08E, 0xD8FB, 0xFCBE, 0x6A00, 0x81C6, 0x007C, 0xAC0A, 0xC074,
0x0AB4, 0x0EB7, 0x00B3, 0x07CD, 0x10EB, 0xF133, 0xC0CD, 0x16CD,
0x19BE, 0xB300, 0x81C6, 0x007C, 0xEBE2, 0x0D0A, 0x4E6F, 0x6E2D,
0x5379, 0x7374, 0x656D, 0x2064, 0x6973, 0x6B20, 0x6F72, 0x2064,
0x6973, 0x6B20, 0x6572, 0x726F, 0x720D, 0x0A52, 0x6570, 0x6C61,
0x6365, 0x2061, 0x6E64, 0x2073, 0x7472, 0x696B, 0x6520, 0x616E,
0x7920, 0x6B65, 0x7920, 0x7768, 0x656E, 0x2072, 0x6561, 0x6479,
0x0D0A, 0x000D, 0x0A44, 0x6973, 0x6B20, 0x426F, 0x6F74, 0x2066,
0x6169, 0x6C75, 0x7265, 0x0D0A, 0x0000};
#endif  /* (LITTLE_ENDIAN) */



const FORMAT_DEC_TREE f_d_c[] = 
{
	{ 8, 512,   10240L},    /* 8 sec per cluster for 0 to 5 M */
	{ 8, 512,   32768L},    /* 8 sec per cluster for 0 to 16M */
	{ 8, 512,  262144L},    /* 8 sec per cluster for 16M to 128M */
	{ 8, 512,  524288L},    /* 8 sec per cluster for 128M to 256M */
	{16, 512, 1048576L},    /* 16 sec per cluster for 128M to 256M */
	{16, 512, 1048576L}     /* 16 sec per cluster for > 256M */
};

/* SanDisk Volume label  "SANVOL" */
const TEXT sdvolume_label[12] = {0x53,0x41,0x4E,0x56,0x4F,0x4C,0x20,0x20,0x20,0x20,0x20,0x00};


#endif  /* (RTFS_WRITE) */




/* It is cleaner to claim global data from the BSS. Instead of using 
** malloc, we declare place holders in the BSS for the various sections. 
*/
DDRIVE  _mem_drives_structures[NDRIVES];
BLKBUFF _mem_block_pool[NBLKBUFFS];
PC_FILE _mem_file_pool[NUSERFILES];
DROBJ   _mem_drobj_pool[NDROBJS];
FINODE  _mem_finode_pool[NFINODES];

/* Each mounted drive needs core to store either the whole FAT in core
** or to store portions of it in core with swapping to disk. 
** These declarations preallocate buffers in the BSS for this purpose.
** see the routiune pc_memory_fat_blocks_alloc() in this file for 
** how these blocks are used.
*/
BLOCK_ALLOC fat_drives[FAT_BUFFER_SIZE*NDRIVES];


/* This buffer is to handle the DIRECTORY access by buffering
** the information to RAM.
** It is internal to the File System
*/
BLOCK_ALLOC directory_buffer[NBLKBUFFS];


/* Full string path for File System use internally */
UINT16  fspath[EMAXPATH];
UINT16  currFileName[EMAXPATH];
TEXT    *longFileName = SDNULL;
TEXT    *saveFileName = SDNULL;
SDWCHAR	unicodeFileName[EMAXPATH];


/* Initialize all pointers to a known state */
FINODE  *inoroot = SDNULL;      /* Begining of inode pool */
DDRIVE  *mem_drives_structures = SDNULL;
BLKBUFF *mem_block_pool = SDNULL;
PC_FILE *mem_file_pool = SDNULL;
DROBJ   *mem_drobj_pool = SDNULL;
FINODE  *mem_finode_pool = SDNULL;
FINODE  *mem_finode_freelist = SDNULL;
DROBJ   *mem_drobj_freelist = SDNULL;


/* Area used by the block buffer pool system */
DDRIVE  *scratch_pdrive = SDNULL;
BLKBUFF *fslocal_buffer = SDNULL;
UINT32   useindex = 0L;

/* Area used by the block pckernel area */
FILE_SYSTEM_USER _user_heap[NUM_USERS];




/*****************************************************************************
* Name: null_pointer
*
* Description:
*       Set all pointer to NULL during file system initialization.
*
* Entries:
*       None
*
* Returns:
*       None
*
******************************************************************************/
SDVOID null_pointers(SDVOID) /* __fn__*/
{
	inoroot = SDNULL;
	mem_drives_structures = SDNULL;
	mem_block_pool = SDNULL;
	mem_file_pool = SDNULL;
	mem_drobj_pool = SDNULL;
	mem_drobj_freelist = SDNULL;
	mem_finode_pool = SDNULL;
	mem_finode_freelist = SDNULL;
	scratch_pdrive = SDNULL;
	fslocal_buffer = SDNULL;
	
	useindex = 0L;
}

#endif /* (USE_FILE_SYSTEM) */

